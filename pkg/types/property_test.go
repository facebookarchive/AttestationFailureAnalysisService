package types

import (
	"fmt"
	"reflect"
	"sort"
	"strings"
	"testing"

	"github.com/9elements/converged-security-suite/v2/pkg/pcr"
	"github.com/9elements/converged-security-suite/v2/pkg/registers"
	"github.com/9elements/go-linux-lowlevel-hw/pkg/platformsecurity"
	"github.com/google/go-tpm/tpm2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type propertiesFromFlowTestCase struct {
	Flow               pcr.Flow
	ExpectedProperties Properties
	StatusRegisters    registers.Registers
	ExpectedTags       MeasurementTags
}

func (s Properties) sort() {
	sort.Slice(s, func(i, j int) bool {
		return reflect.TypeOf(s[i]).String() < reflect.TypeOf(s[j]).String()
	})
}

func (s MeasurementTags) sort() {
	sort.Slice(s, func(i, j int) bool {
		return s[i] < s[j]
	})
}

func TestFindMeasurementTagByName(t *testing.T) {
	result, found := FindMeasurementTagByName(TXTEnabledTag.String())
	require.True(t, found)
	require.Equal(t, TXTEnabledTag, result)

	_, found = FindMeasurementTagByName("AAAAAAAAA")
	require.False(t, found)
}

func TestAreEqualMeasurementTags(t *testing.T) {
	require.True(t, AreEqualMeasurementTagsSets(nil, nil))
	require.True(t, AreEqualMeasurementTagsSets(MeasurementTags{TXTEnabledTag, TPM12Tag}, MeasurementTags{TPM12Tag, TXTEnabledTag}))
	require.True(t, AreEqualMeasurementTagsSets(MeasurementTags{TXTEnabledTag, TPM12Tag, TPM12Tag}, MeasurementTags{TPM12Tag, TXTEnabledTag, TXTEnabledTag}))
	require.False(t, AreEqualMeasurementTagsSets(MeasurementTags{TXTEnabledTag, TPM12Tag, PCRAutoGeneratedTag}, MeasurementTags{TPM12Tag, TPM12Tag, TXTEnabledTag}))
	require.False(t, AreEqualMeasurementTagsSets(MeasurementTags{TXTDisabledTag, TPM12Tag}, MeasurementTags{TPM12Tag, TXTEnabledTag}))
}

func TestIsPCRMeasurementTags(t *testing.T) {
	require.True(t, MeasurementTags{TXTEnabledTag}.IsPCRValue())
	require.True(t, MeasurementTags{TXTDisabledTag}.IsPCRValue())
	require.False(t, MeasurementTags{}.IsPCRValue())
}

func TestMeasurementTagsPlatformSecurity(t *testing.T) {
	testCases := []struct {
		tag                      MeasurementTag
		expectedPlatformSecurity platformsecurity.ID
	}{
		{
			tag:                      DCDEnabledTag,
			expectedPlatformSecurity: platformsecurity.IDIntelCBnT,
		},
		{
			tag:                      TXTEnabledTag,
			expectedPlatformSecurity: platformsecurity.IDIntelTXT,
		},
		{
			tag:                      PSPEnabledTag,
			expectedPlatformSecurity: platformsecurity.IDAMDMilan,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.tag.String(), func(t *testing.T) {
			assert.Equal(t, tc.expectedPlatformSecurity, tc.tag.PlatformSecurity())
		})
	}
}

func TestProperties(t *testing.T) {
	t.Run("FlowAuto", func(t *testing.T) {
		// For "FlowAuto" properties are undefined. It is required to use
		// functions "pcr.Detect*Flow" before calling "PropertiesFromFlow".
		props, err := PropertiesFromFlow(pcr.FlowAuto, nil)
		require.Nil(t, props)
		require.Error(t, err)
	})

	for _, testCase := range []propertiesFromFlowTestCase{
		{
			Flow:               pcr.FlowIntelLegacyTXTDisabled,
			ExpectedProperties: Properties{PropertyIntelTXT(false)},
			ExpectedTags:       MeasurementTags{TXTDisabledTag},
		},
		{
			Flow: pcr.FlowIntelLegacyTXTEnabled,
			ExpectedProperties: Properties{
				PropertyIntelTXT(true),
				PropertyTPMVersion{Major: 2, Minor: 0},
			},
			ExpectedTags: MeasurementTags{
				TXTEnabledTag,
				TPM20Tag,
			},
		},
		{
			Flow: pcr.FlowIntelLegacyTXTEnabledTPM12,
			ExpectedProperties: Properties{
				PropertyIntelTXT(true),
				PropertyTPMVersion{Major: 1, Minor: 2},
			},
			ExpectedTags: MeasurementTags{
				TXTEnabledTag,
				TPM12Tag,
			},
		},
		{
			Flow: pcr.FlowIntelCBnT0T,
			ExpectedProperties: Properties{
				PropertyIntelTXT(true),
				PropertyTPMVersion{Major: 2, Minor: 0},
				PropertyIntelDCD(true),
				PropertyIntelDBI(false),
			},
			StatusRegisters: registers.Registers{registers.ACMPolicyStatus(1 << 9)},
			ExpectedTags: MeasurementTags{
				TXTEnabledTag,
				TPM20Tag,
				DCDEnabledTag,
				DBIDisabledTag,
			},
		},
		{
			Flow: pcr.FlowIntelCBnT0T,
			ExpectedProperties: Properties{
				PropertyIntelTXT(true),
				PropertyTPMVersion{Major: 2, Minor: 0},
				PropertyIntelDCD(false),
				PropertyIntelDBI(true),
			},
			StatusRegisters: registers.Registers{registers.ACMPolicyStatus(1 << 10)},
			ExpectedTags: MeasurementTags{
				TXTEnabledTag,
				TPM20Tag,
				DCDDisabledTag,
				DBIEnabledTag,
			},
		},
		{
			Flow: pcr.FlowAMDLocality3,
			ExpectedProperties: Properties{
				PropertyAMDPlatformSecurityProcessor(true),
				PropertyTPMVersion{Major: 2, Minor: 0},
			},
			ExpectedTags: MeasurementTags{
				PSPEnabledTag,
				TPM20Tag,
			},
		},
		{
			Flow: pcr.FlowAMDLocality3,
			ExpectedProperties: Properties{
				PropertyAMDPlatformSecurityProcessor(true),
				PropertyAMDPlatformSecureBoot(false),
				PropertyTPMVersion{Major: 2, Minor: 0},
			},
			StatusRegisters: registers.Registers{registers.ParseMP0C2PMsg37Register(0)},
			ExpectedTags: MeasurementTags{
				PSPEnabledTag,
				PSBDisabledTag,
				TPM20Tag,
			},
		},
		{
			Flow: pcr.FlowAMDLocality3,
			ExpectedProperties: Properties{
				PropertyAMDPlatformSecurityProcessor(true),
				PropertyAMDPlatformSecureBoot(true),
				PropertyTPMVersion{Major: 2, Minor: 0},
			},
			StatusRegisters: registers.Registers{registers.ParseMP0C2PMsg37Register(0xffffffff)},
			ExpectedTags: MeasurementTags{
				PSPEnabledTag,
				PSBEnabledTag,
				TPM20Tag,
			},
		},
	} {
		t.Run(fmt.Sprintf("flow_%s_registers_%v", testCase.Flow.String(), testCase.StatusRegisters), func(t *testing.T) {
			require.NoError(t, testCase.ExpectedProperties.Validate())

			props, err := PropertiesFromFlow(testCase.Flow, testCase.StatusRegisters)
			require.NoError(t, err)
			require.NoError(t, props.Validate())

			testCase.ExpectedProperties.sort()
			props.sort()
			require.Equal(t, testCase.ExpectedProperties, props)

			testCase.ExpectedTags.sort()
			tags := props.Tags()
			tags.sort()
			require.Equal(t, testCase.ExpectedTags, tags)

			require.True(t, testCase.ExpectedProperties.ContainsAll(props...))
			props = append(props, props[0])
			require.True(t, testCase.ExpectedProperties.ContainsAll(props...))

			require.True(t, props.ContainsType(testCase.ExpectedProperties[0]))
			require.False(t, testCase.ExpectedProperties.ContainsType(Property(nil)))
		})
	}
}

func TestPropertiesBrokenValidation(t *testing.T) {
	brokenProperties := []Properties{
		{
			PropertyIntelTXT(true),
			PropertyIntelTXT(false),
		},
		{
			PropertyTPMVersion{Major: 2, Minor: 0},
			PropertyTPMVersion{Major: 1, Minor: 2},
		},
		{
			PropertyIntelDCD(true),
			PropertyIntelDCD(false),
		},
		{
			PropertyIntelDBI(true),
			PropertyIntelDBI(false),
		},
		{
			PropertyIntelTXT(true),
			PropertyAMDPlatformSecureBoot(true),
		},
	}

	for _, props := range brokenProperties {
		require.Error(t, props.Validate())
	}
}

func TestDuplicatePropertiesValidation(t *testing.T) {
	props := Properties{
		PropertyIntelTXT(true),
		PropertyIntelTXT(true),
		PropertyTPMVersion{Major: 2, Minor: 0},
		PropertyTPMVersion{Major: 2, Minor: 0},
		PropertyIntelDCD(false),
		PropertyIntelDCD(false),
		PropertyIntelDBI(true),
		PropertyIntelDBI(true),
	}
	require.NoError(t, props.Validate())
}

func TestPropertiesFindByType(t *testing.T) {
	props := Properties{
		PropertyIntelTXT(true),
		PropertyTPMVersion{Major: 2, Minor: 0},
		PropertyIntelDCD(false),
	}

	intelTXT := props.FindByType(PropertyIntelTXT(false))
	require.Equal(t, PropertyIntelTXT(true), intelTXT)

	require.Nil(t, props.FindByType(PropertyIntelDBI(false)))
}

func TestPropertyToTagConversion(t *testing.T) {
	cases := []struct {
		tag      MeasurementTag
		property Property
	}{
		{
			tag:      NPIWorkaround,
			property: PropertyNPIWorkaround(true),
		},
	}

	for _, tc := range cases {
		require.Equal(t, tc.property, tc.tag.Property())
		require.Equal(t, tc.tag, tc.property.Tag())
	}
}

func TestPropertyParse(t *testing.T) {
	t.Run("positive", func(t *testing.T) {
		mTags := MeasurementTags{
			PCR0SHA1Tag,
			TXTEnabledTag,
			TPM12Tag,
			NPIWorkaround,
		}
		pcrIndex, hashAlgo, props, err := mTags.Parse()
		require.NoError(t, err)
		assert.Equal(t, int8(0), pcrIndex)
		assert.Equal(t, tpm2.AlgSHA1, hashAlgo)
		assert.Equal(t, Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 1, Minor: 2},
			PropertyNPIWorkaround(true),
		}, props)
	})

	// checking error by substrings only because the errors has no special types, unfortunatelly.

	t.Run("undefined_tag", func(t *testing.T) {
		mTags := MeasurementTags{
			tagUndefined,
		}
		_, _, _, err := mTags.Parse()
		require.Error(t, err)
		require.True(t, strings.Contains(err.Error(), "undefined"))
	})

	t.Run("inconsistent_PCR_index", func(t *testing.T) {
		mTags := MeasurementTags{
			PCR0SHA1Tag,
			PCR1SHA1Tag,
		}
		_, _, _, err := mTags.Parse()
		require.Error(t, err)
		require.True(t, strings.Contains(err.Error(), "are inconsistent: multiple PCR indexes"), err.Error())
	})

	t.Run("inconsistent_hash_algo", func(t *testing.T) {
		mTags := MeasurementTags{
			PCR0SHA1Tag,
			PCR0SHA256Tag,
		}
		_, _, _, err := mTags.Parse()
		require.Error(t, err)
		require.True(t, strings.Contains(err.Error(), "are inconsistent: multiple hash algos"), err.Error())
	})
}
