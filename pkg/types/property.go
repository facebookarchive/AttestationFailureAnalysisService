package types

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/immune-gmbh/AttestationFailureAnalysisService/if/generated/tpm"

	"github.com/9elements/converged-security-suite/v2/pkg/errors"
	"github.com/9elements/converged-security-suite/v2/pkg/pcr"
	"github.com/9elements/converged-security-suite/v2/pkg/registers"
	"github.com/9elements/go-linux-lowlevel-hw/pkg/platformsecurity"
)

// Property is an abstract property defined by a tag.
//
// TODO: remove this entity after migration to Firmware Portal V2. It won't
//
//	have "tags" anymore, so this logic could be reduced, and a Thrift
//	definition (see "rtp.thrift") could be used, instead.
type Property any

// PropertyTPMVersion defines the TPM (Trusted Platform Module) version.
type PropertyTPMVersion tpm.Version

// PropertyIntelTXT defines if Intel TXT is enabled/disabled.
//
// Do not set this property for non-Intel systems.
type PropertyIntelTXT bool

// PropertyAMDPlatformSecurityProcessor defines if it is an AMD PSP platform
//
// Do not set this property for non-Intel systems.
type PropertyAMDPlatformSecurityProcessor bool

// PropertyAMDPlatformSecureBoot defines if AMD PSB is enabled/disabled.
//
// Do not set this property for non-Intel systems.
type PropertyAMDPlatformSecureBoot bool

// PropertyIntelDBI defines if "Disable BSP init" bit is set.
//
// Do not set this property for non-Intel systems.
type PropertyIntelDBI bool

// PropertyIntelDCD defines if "Disable CPU debug" bit is set.
//
// Do not set this property for non-Intel systems.
type PropertyIntelDCD bool

// PropertyAutoGenerated defines that PCR value was auto-generated
type PropertyAutoGenerated bool

// PropertyPCRValidated defines a PCR value that was validated by RTP checker
type PropertyPCRValidated bool

// PropertyNPIWorkaround tells that PCR is a "hack" for an NPI program
type PropertyNPIWorkaround bool

// Properties is a set of Property-es.
type Properties []Property

// ContainsType returns true if Properties contains a Property of the same
// type as sample.
func (s Properties) ContainsType(sample Property) bool {
	if sample == nil {
		return false
	}
	sampleType := reflect.Indirect(reflect.ValueOf(sample)).Type()
	for _, prop := range s {
		propType := reflect.Indirect(reflect.ValueOf(prop)).Type()
		if propType == sampleType {
			return true
		}
	}

	return false
}

// FindByType returns the first found actual property value of the same
// type as sample.
func (s Properties) FindByType(sample Property) Property {
	if sample == nil {
		return nil
	}
	sampleType := reflect.Indirect(reflect.ValueOf(sample)).Type()
	for _, prop := range s {
		propType := reflect.Indirect(reflect.ValueOf(prop)).Type()
		if propType == sampleType {
			return prop
		}
	}
	return nil
}

// Equals returns true if (and only if) `cmp` contains the same set of values as `s`.
// Repeated values (within a set) are ignored.
func (s Properties) Equals(cmp Properties) bool {
	expect := map[Property]struct{}{}
	for _, prop := range cmp {
		expect[prop] = struct{}{}
	}
	found := map[Property]struct{}{}
	for _, prop := range s {
		if _, ok := expect[prop]; !ok {
			return false
		}
		found[prop] = struct{}{}
	}
	return len(expect) == len(found)
}

// FromThrift converts Properties from Thrift format to the internal one.
func (s *Properties) FromThrift(props thrift_rtp.PCRProperties) {
	*s = (*s)[:0]
	if props.AFAS != nil {
		if props.AFAS.AutoGenerated != nil {
			*s = append(*s, PropertyAutoGenerated(*props.AFAS.AutoGenerated))
		}
	}
	if props.TPM != nil {
		if props.TPM.Version != nil {
			*s = append(*s, PropertyTPMVersion(*props.TPM.Version))
		}
	}
	if props.Intel != nil {
		if props.Intel.TXTEnabled != nil {
			*s = append(*s, PropertyIntelTXT(*props.Intel.TXTEnabled))
		}
		if props.Intel.DBI != nil {
			*s = append(*s, PropertyIntelDBI(*props.Intel.DBI))
		}
		if props.Intel.DCD != nil {
			*s = append(*s, PropertyIntelDCD(*props.Intel.DCD))
		}
	}
	if props.AMD != nil {
		*s = append(*s, PropertyAMDPlatformSecurityProcessor(true))
		if props.AMD.PlatformSecureBoot != nil {
			*s = append(*s, PropertyAMDPlatformSecureBoot(*props.AMD.PlatformSecureBoot))
		}
	}
}

// ToThrift converts Properties to Thrift format from the internal one.
func (s Properties) ToThrift() thrift_rtp.PCRProperties {
	var result thrift_rtp.PCRProperties
	for _, prop := range s {
		switch prop.(type) {
		case PropertyAutoGenerated:
			if result.AFAS == nil {
				result.AFAS = &thrift_rtp.PCRPropertiesAFAS{}
			}
		case PropertyTPMVersion:
			if result.TPM == nil {
				result.TPM = &thrift_rtp.PCRPropertiesTPM{}
			}
		case PropertyIntelTXT, PropertyIntelDCD, PropertyIntelDBI:
			if result.Intel == nil {
				result.Intel = &thrift_rtp.PCRPropertiesIntel{}
			}
		case PropertyAMDPlatformSecureBoot, PropertyAMDPlatformSecurityProcessor:
			if result.AMD == nil {
				result.AMD = &thrift_rtp.PCRPropertiesAMD{}
			}
		}
		switch prop := prop.(type) {
		case PropertyAutoGenerated:
			result.AFAS.AutoGenerated = (*bool)(&prop)
		case PropertyTPMVersion:
			result.TPM.Version = (*tpm.Version)(&prop)
		case PropertyIntelTXT:
			result.Intel.TXTEnabled = (*bool)(&prop)
		case PropertyIntelDCD:
			result.Intel.DCD = (*bool)(&prop)
		case PropertyIntelDBI:
			result.Intel.DBI = (*bool)(&prop)
		case PropertyAMDPlatformSecureBoot:
			result.AMD.PlatformSecureBoot = (*bool)(&prop)
		}
	}

	return result
}

// PropertiesFromFlow converts flow with statusRegisters to Properties.
func PropertiesFromFlow(flow pcr.Flow, statusRegisters registers.Registers) (Properties, error) {
	switch flow {
	case pcr.FlowIntelLegacyTXTDisabled:
		return Properties{
			PropertyIntelTXT(false),
		}, nil
	case pcr.FlowIntelLegacyTXTEnabled:
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 2, Minor: 0},
		}, nil
	case pcr.FlowIntelLegacyTXTEnabledTPM12:
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 1, Minor: 2},
		}, nil
	case pcr.FlowIntelCBnT0T:
		acmPolicyStatusRegister, found := registers.FindACMPolicyStatus(statusRegisters)
		if !found {
			return nil, fmt.Errorf("ACM_POLICY_STATUS register not found")
		}
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 2, Minor: 0},
			PropertyIntelDCD(acmPolicyStatusRegister.BootPolicyDCD()),
			PropertyIntelDBI(acmPolicyStatusRegister.BootPolicyDBI()),
		}, nil
	case pcr.FlowAMDLocality0, pcr.FlowAMDLocality3, pcr.FlowLegacyAMDLocality0, pcr.FlowLegacyAMDLocality3:
		result := Properties{
			PropertyTPMVersion{Major: 2, Minor: 0},
			PropertyAMDPlatformSecurityProcessor(true),
		}
		if msg37Register, found := registers.FindMP0C2PMsg37(statusRegisters); found {
			result = append(result, PropertyAMDPlatformSecureBoot(msg37Register.IsPlatformSecureBootEnabled()))
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unknown flow: %s", flow)
	}
}

// ContainsAll returns if props is a subset of s.
func (s Properties) ContainsAll(props ...Property) bool {
	m := map[Property]struct{}{}
	for _, prop := range s {
		m[prop] = struct{}{}
	}

	for _, prop := range props {
		if _, ok := m[prop]; !ok {
			return false
		}
	}

	return true
}

// Validate returns an error if properties are invalid.
func (s Properties) Validate() error {
	mErr := &errors.MultiError{}

	m := map[reflect.Type]Property{}
	for _, prop := range s {
		if prop == nil {
			mErr.Add(fmt.Errorf("property is nil"))
			continue
		}

		t := reflect.TypeOf(prop)
		current := m[t]
		if current == nil {
			m[t] = prop
		} else {
			if !reflect.DeepEqual(current, prop) {
				mErr.Add(fmt.Errorf("property %s is defined multiple times and contains a contradiction: %v and %v", strings.ReplaceAll(t.String(), "types.Property", ""), current, prop))
				break
			}
		}
	}

	return mErr.ReturnValue()
}

func compatiblePlatformSecurity(lhv, rhv platformsecurity.ID) bool {
	// CBnT and TXT and compatible
	if lhv == platformsecurity.IDIntelCBnT {
		lhv = platformsecurity.IDIntelTXT
	}
	if rhv == platformsecurity.IDIntelCBnT {
		rhv = platformsecurity.IDIntelTXT
	}
	return lhv == rhv
}
