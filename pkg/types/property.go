package types

import (
	"fmt"
	"reflect"
	"strings"

	thrift_rtp "github.com/immune-gmbh/AttestationFailureAnalysisService/if/rtp"
	"github.com/immune-gmbh/AttestationFailureAnalysisService/if/tpm"

	"github.com/9elements/converged-security-suite/v2/pkg/errors"
	"github.com/9elements/converged-security-suite/v2/pkg/pcr"
	"github.com/9elements/converged-security-suite/v2/pkg/registers"
	"github.com/9elements/go-linux-lowlevel-hw/pkg/platformsecurity"
	"github.com/google/go-tpm/tpm2"
	"github.com/hashicorp/go-multierror"
)

// TagID represents an integer tag label from TagStore
type TagID uint64

// TagIDs is a slice of TagID-s
type TagIDs []TagID

// Clean copies the slice without zero values.
func (s TagIDs) Clean() TagIDs {
	var r TagIDs
	for _, tagID := range s {
		if tagID == 0 {
			continue
		}
		r = append(r, tagID)
	}
	return r
}

// Property is an abstract property defined by a tag.
//
// TODO: remove this entity after migration to Firmware Portal V2. It won't
//
//	have "tags" anymore, so this logic could be reduced, and a Thrift
//	definition (see "rtp.thrift") could be used, instead.
type Property interface {
	Tag() MeasurementTag
}

// PropertyTPMVersion defines the TPM (Trusted Platform Module) version.
type PropertyTPMVersion tpm.Version

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyTPMVersion) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyIntelTXT defines if Intel TXT is enabled/disabled.
//
// Do not set this property for non-Intel systems.
type PropertyIntelTXT bool

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyIntelTXT) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyAMDPlatformSecurityProcessor defines if it is an AMD PSP platform
//
// Do not set this property for non-Intel systems.
type PropertyAMDPlatformSecurityProcessor bool

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyAMDPlatformSecurityProcessor) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyAMDPlatformSecureBoot defines if AMD PSB is enabled/disabled.
//
// Do not set this property for non-Intel systems.
type PropertyAMDPlatformSecureBoot bool

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyAMDPlatformSecureBoot) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyIntelDBI defines if "Disable BSP init" bit is set.
//
// Do not set this property for non-Intel systems.
type PropertyIntelDBI bool

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyIntelDBI) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyIntelDCD defines if "Disable CPU debug" bit is set.
//
// Do not set this property for non-Intel systems.
type PropertyIntelDCD bool

// Tag implements Property.
// TODO: remove Tag duplication when Go generic will be released.
func (prop PropertyIntelDCD) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyAutoGenerated defines that PCR value was auto-generated
type PropertyAutoGenerated bool

// Tag implements Property.
func (prop PropertyAutoGenerated) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyPCRValidated defines a PCR value that was validated by RTP checker
type PropertyPCRValidated bool

// Tag implements Property.
func (prop PropertyPCRValidated) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// PropertyNPIWorkaround tells that PCR is a "hack" for an NPI program
type PropertyNPIWorkaround bool

// Tag implements Property.
func (prop PropertyNPIWorkaround) Tag() MeasurementTag {
	return TagFromProperty(prop)
}

// TagFromProperty converts a Property to the MeasurementTag.
func TagFromProperty(prop Property) MeasurementTag {
	for _, tag := range AllMeasurementTags {
		if tag.Property() == prop {
			return tag
		}
	}

	return tagUndefined
}

// Properties is a set of Property-es.
type Properties []Property

// GoString implement fmt.GoStringer
func (s Properties) GoString() string {
	var r []string
	for _, prop := range s {
		tag := prop.Tag()
		if tag == tagUndefined {
			r = append(r, fmt.Sprintf("%T(%v)", prop, prop))
			continue
		}
		r = append(r, tag.String())
	}
	return strings.Join(r, ",")
}

// Tags converts Properties to MeasurementTags.
func (s Properties) Tags() MeasurementTags {
	result := make(MeasurementTags, 0, len(s))
	for _, prop := range s {
		result = append(result, prop.Tag())
	}
	return result
}

// ContainsType returns true if Properties contains a Property of the same
// type as sample.
func (s Properties) ContainsType(sample Property) bool {
	if sample == nil {
		return false
	}
	sampleType := reflect.Indirect(reflect.ValueOf(sample)).Type()
	for _, prop := range s {
		propType := reflect.Indirect(reflect.ValueOf(prop)).Type()
		if propType == sampleType {
			return true
		}
	}

	return false
}

// FindByType returns the first found actual property value of the same
// type as sample.
func (s Properties) FindByType(sample Property) Property {
	if sample == nil {
		return nil
	}
	sampleType := reflect.Indirect(reflect.ValueOf(sample)).Type()
	for _, prop := range s {
		propType := reflect.Indirect(reflect.ValueOf(prop)).Type()
		if propType == sampleType {
			return prop
		}
	}
	return nil
}

// Equals returns true if (and only if) `cmp` contains the same set of values as `s`.
// Repeated values (within a set) are ignored.
func (s Properties) Equals(cmp Properties) bool {
	expect := map[Property]struct{}{}
	for _, prop := range cmp {
		expect[prop] = struct{}{}
	}
	found := map[Property]struct{}{}
	for _, prop := range s {
		if _, ok := expect[prop]; !ok {
			return false
		}
		found[prop] = struct{}{}
	}
	return len(expect) == len(found)
}

// FromThrift converts Properties from Thrift format to the internal one.
func (s *Properties) FromThrift(props thrift_rtp.PCRProperties) {
	*s = (*s)[:0]
	if props.AFAS != nil {
		if props.AFAS.AutoGenerated != nil {
			*s = append(*s, PropertyAutoGenerated(*props.AFAS.AutoGenerated))
		}
	}
	if props.TPM != nil {
		if props.TPM.Version != nil {
			*s = append(*s, PropertyTPMVersion(*props.TPM.Version))
		}
	}
	if props.Intel != nil {
		if props.Intel.TXTEnabled != nil {
			*s = append(*s, PropertyIntelTXT(*props.Intel.TXTEnabled))
		}
		if props.Intel.DBI != nil {
			*s = append(*s, PropertyIntelDBI(*props.Intel.DBI))
		}
		if props.Intel.DCD != nil {
			*s = append(*s, PropertyIntelDCD(*props.Intel.DCD))
		}
	}
	if props.AMD != nil {
		*s = append(*s, PropertyAMDPlatformSecurityProcessor(true))
		if props.AMD.PlatformSecureBoot != nil {
			*s = append(*s, PropertyAMDPlatformSecureBoot(*props.AMD.PlatformSecureBoot))
		}
	}
}

// ToThrift converts Properties to Thrift format from the internal one.
func (s Properties) ToThrift() thrift_rtp.PCRProperties {
	var result thrift_rtp.PCRProperties
	for _, prop := range s {
		switch prop.(type) {
		case PropertyAutoGenerated:
			if result.AFAS == nil {
				result.AFAS = &thrift_rtp.PCRPropertiesAFAS{}
			}
		case PropertyTPMVersion:
			if result.TPM == nil {
				result.TPM = &thrift_rtp.PCRPropertiesTPM{}
			}
		case PropertyIntelTXT, PropertyIntelDCD, PropertyIntelDBI:
			if result.Intel == nil {
				result.Intel = &thrift_rtp.PCRPropertiesIntel{}
			}
		case PropertyAMDPlatformSecureBoot, PropertyAMDPlatformSecurityProcessor:
			if result.AMD == nil {
				result.AMD = &thrift_rtp.PCRPropertiesAMD{}
			}
		}
		switch prop := prop.(type) {
		case PropertyAutoGenerated:
			result.AFAS.AutoGenerated = (*bool)(&prop)
		case PropertyTPMVersion:
			result.TPM.Version = (*tpm.Version)(&prop)
		case PropertyIntelTXT:
			result.Intel.TXTEnabled = (*bool)(&prop)
		case PropertyIntelDCD:
			result.Intel.DCD = (*bool)(&prop)
		case PropertyIntelDBI:
			result.Intel.DBI = (*bool)(&prop)
		case PropertyAMDPlatformSecureBoot:
			result.AMD.PlatformSecureBoot = (*bool)(&prop)
		}
	}

	return result
}

// MeasurementTag is type for resolved firmware hash tags regarding to measurements
type MeasurementTag uint32

// PCRBank returns PCR index and hash algorithm of the PCR value.
//
// Returns (-1, tpm2.AlgUnknown) if the tag does not define PCR index
// or/and hash algorithm.
//
// Returns non-negative pcrIndex and non-Unknown hash algorithm if the tag
// defines them.
func (tag MeasurementTag) PCRBank() (pcrIndex int8, hashAlgo tpm2.Algorithm) {
	switch tag {
	case PCR0SHA1Tag:
		return 0, tpm2.AlgSHA1
	case PCR0SHA256Tag:
		return 0, tpm2.AlgSHA256
	case PCR1SHA1Tag:
		return 1, tpm2.AlgSHA1
	}
	return -1, tpm2.AlgUnknown
}

// Property converts the tag to Property.
func (tag MeasurementTag) Property() Property {
	switch tag {
	case TXTDisabledTag:
		return PropertyIntelTXT(false)
	case TXTEnabledTag:
		return PropertyIntelTXT(true)
	case PSPEnabledTag:
		return PropertyAMDPlatformSecurityProcessor(true)
	case PSBDisabledTag:
		return PropertyAMDPlatformSecureBoot(false)
	case PSBEnabledTag:
		return PropertyAMDPlatformSecureBoot(true)
	case TPM12Tag:
		return PropertyTPMVersion{
			Major: 1,
			Minor: 2,
		}
	case TPM20Tag:
		return PropertyTPMVersion{
			Major: 2,
			Minor: 0,
		}
	case DBIEnabledTag:
		return PropertyIntelDBI(true)
	case DBIDisabledTag:
		return PropertyIntelDBI(false)
	case DCDEnabledTag:
		return PropertyIntelDCD(true)
	case DCDDisabledTag:
		return PropertyIntelDCD(false)
	case PCRAutoGeneratedTag:
		return PropertyAutoGenerated(true)
	case PCRValidated:
		return PropertyPCRValidated(true)
	case NPIWorkaround:
		return PropertyNPIWorkaround(true)
	}

	return nil
}

// PlatformSecurity returns a platform security ID associated with the measurement tag or Undefined
func (tag MeasurementTag) PlatformSecurity() platformsecurity.ID {
	switch tag {
	case TXTDisabledTag, TXTEnabledTag:
		return platformsecurity.IDIntelTXT
	case DBIEnabledTag, DBIDisabledTag, DCDEnabledTag, DCDDisabledTag:
		return platformsecurity.IDIntelCBnT
	case PSPEnabledTag, PSBEnabledTag, PSBDisabledTag:
		return platformsecurity.IDAMDMilan
	}
	return platformsecurity.IDUndefined
}

// String implements fmt.Stringer.
func (tag MeasurementTag) String() string {
	switch tag {
	case TXTDisabledTag:
		return "TXT_DISABLED"
	case TXTEnabledTag:
		return "TXT_ENABLED"
	case TPM12Tag:
		return "TPM1.2"
	case TPM20Tag:
		return "TPM2.0"
	case PCR0SHA1Tag:
		return "PCR0_SHA1"
	case PCR0SHA256Tag:
		return "PCR0_SHA256"
	case PCR1SHA1Tag:
		return "PCR1_SHA1"
	case DBIEnabledTag:
		return "DBI_ENABLED"
	case DBIDisabledTag:
		return "DBI_DISABLED"
	case DCDEnabledTag:
		return "DCD_ENABLED"
	case DCDDisabledTag:
		return "DCD_DISABLED"
	case PSBDisabledTag:
		return "PSB_DISABLED"
	case PSBEnabledTag:
		return "PSB_ENABLED"
	case PSPEnabledTag:
		return "PSP_ENABLED"
	case PCRAutoGeneratedTag:
		return "PCR_AUTOGENERATED"
	case PCRValidated:
		return "PCR_VALIDATED"
	case NPIWorkaround:
		return "NPI_WORKAROUND"
	}
	return fmt.Sprintf("unknown_mtag_%d", uint32(tag))
}

// FindMeasurementTagByName returns a MeasurementTag that corresponds to a given name
func FindMeasurementTagByName(name string) (result MeasurementTag, found bool) {
	for _, tag := range AllMeasurementTags {
		if name == tag.String() {
			return tag, true
		}
	}
	return tagUndefined, false
}

const (
	tagUndefined = MeasurementTag(iota)
	// TXTDisabledTag represents TXT_DISABLED
	TXTDisabledTag
	// TXTEnabledTag represents TXT_ENABLED
	TXTEnabledTag
	// TPM12Tag represents TPM1.2
	TPM12Tag
	// TPM20Tag represents TPM2.0
	TPM20Tag
	// PCR0SHA1Tag represents PCR0_SHA1
	PCR0SHA1Tag
	// PCR0SHA256Tag represents PCR0_SHA256
	PCR0SHA256Tag
	// PCR1SHA1Tag represents PCR1_SHA1
	// Is curently used only for unit-tests.
	PCR1SHA1Tag
	// DBIEnabledTag represents DBI_ENABLED
	DBIEnabledTag
	// DBIDisabledTag represents DBI_DISABLED
	DBIDisabledTag
	// DCDEnabledTag represents DCD_ENABLED
	DCDEnabledTag
	// DCDDisabledTag represents DCD_DISABLED
	DCDDisabledTag
	// PCRAutoGeneratedTag represents PCE_AUTOGENERATED
	// All PCR values generated by AFAS should have this tag
	PCRAutoGeneratedTag
	// PSBDisabledTag represents PSB_DISABLED
	PSBDisabledTag
	// PSBEnabledTag represents PSB_ENABLED
	PSBEnabledTag
	// PSPEnabledTag represents PSP_ENABLED
	PSPEnabledTag
	// PCRValidated represents PCR_VALIDATED
	PCRValidated
	// NPIWorkaround represents NPI_WORKAROUND
	NPIWorkaround
)

// AllMeasurementTags contains a list of all existing measurement tags
var AllMeasurementTags = []MeasurementTag{
	TXTDisabledTag,
	TXTEnabledTag,
	TPM12Tag,
	TPM20Tag,
	PCR0SHA1Tag,
	PCR0SHA256Tag,
	DBIEnabledTag,
	DBIDisabledTag,
	DCDEnabledTag,
	DCDDisabledTag,
	PCRAutoGeneratedTag,
	PSBDisabledTag,
	PSBEnabledTag,
	PSPEnabledTag,
	PCRValidated,
	NPIWorkaround,
}

// MeasurementTags is a set of MeasurementTag-s.
type MeasurementTags []MeasurementTag

// ContainsAll returns true if tags contains is a subset of s.
func (s MeasurementTags) ContainsAll(tags ...MeasurementTag) bool {
	m := map[MeasurementTag]struct{}{}
	for _, tag := range s {
		m[tag] = struct{}{}
	}

	for _, tag := range tags {
		if _, ok := m[tag]; !ok {
			return false
		}
	}

	return true
}

// Parse converts tags to properties and hash algorithm.
func (s MeasurementTags) Parse() (pcrIndex int8, hashAlgo tpm2.Algorithm, props Properties, err error) {
	var (
		resultErr            multierror.Error
		inconsistentPcrIndex = false
		inconsistentHashAlgo = false
	)
	pcrIndex = -1
	hashAlgo = tpm2.AlgUnknown
	for idx, tag := range s {
		if tag == tagUndefined {
			resultErr.Errors = append(resultErr.Errors, fmt.Errorf("tag #%d of set %v is undefined", idx, s))
			continue
		}

		_pcrIndex, _hashAlgo := tag.PCRBank()
		switch {
		case _pcrIndex == -1:
		case pcrIndex == -1:
			pcrIndex = _pcrIndex
		case pcrIndex != _pcrIndex:
			resultErr.Errors = append(resultErr.Errors, fmt.Errorf("tags %v are inconsistent: multiple PCR indexes: %d != %d", s, pcrIndex, _pcrIndex))
			inconsistentPcrIndex = true
		}
		switch {
		case _hashAlgo == tpm2.AlgUnknown:
		case hashAlgo == tpm2.AlgUnknown:
			hashAlgo = _hashAlgo
		case hashAlgo != _hashAlgo:
			resultErr.Errors = append(resultErr.Errors, fmt.Errorf("tags %v are inconsistent: multiple hash algos: %v != %v", s, hashAlgo, _hashAlgo))
			inconsistentHashAlgo = true
		}

		prop := tag.Property()
		if prop == nil {
			continue
		}
		props = append(props, prop)
	}
	if inconsistentPcrIndex {
		pcrIndex = -1
	}
	if inconsistentHashAlgo {
		hashAlgo = tpm2.AlgUnknown
	}

	err = resultErr.ErrorOrNil()
	return
}

// pcrRelatedTags should contain tags meaning that the value should be treated as PCR
var pcrRelatedTags = map[MeasurementTag]struct{}{
	PCR0SHA1Tag:    {},
	PCR0SHA256Tag:  {},
	PCR1SHA1Tag:    {},
	TXTDisabledTag: {},
	TXTEnabledTag:  {},
	PSBDisabledTag: {},
	PSBEnabledTag:  {},
	PSPEnabledTag:  {},
	DBIEnabledTag:  {},
	DBIDisabledTag: {},
	DCDEnabledTag:  {},
	DCDDisabledTag: {},
	PCRValidated:   {},
}

// IsPCRValue determines that the measurement tags correspond to PCR value
func (s MeasurementTags) IsPCRValue() bool {
	for _, tag := range s {
		if _, found := pcrRelatedTags[tag]; found {
			return true
		}
	}
	return false
}

// AreEqualMeasurementTagsSets returns true if both MeasurementTags contain the same element regardless of the number of those elements
func AreEqualMeasurementTagsSets(lhv MeasurementTags, rhv MeasurementTags) bool {
	rhvHM := make(map[MeasurementTag]bool)
	for _, tag := range rhv {
		rhvHM[tag] = false
	}
	var rhvHMMatchedItemsCount int
	for _, tag := range lhv {
		matched, found := rhvHM[tag]
		if !found {
			return false
		}
		if !matched {
			rhvHMMatchedItemsCount++
			rhvHM[tag] = true
		}
	}
	return rhvHMMatchedItemsCount == len(rhvHM)
}

// PropertiesFromFlow converts flow with statusRegisters to Properties.
func PropertiesFromFlow(flow pcr.Flow, statusRegisters registers.Registers) (Properties, error) {
	switch flow {
	case pcr.FlowIntelLegacyTXTDisabled:
		return Properties{
			PropertyIntelTXT(false),
		}, nil
	case pcr.FlowIntelLegacyTXTEnabled:
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 2, Minor: 0},
		}, nil
	case pcr.FlowIntelLegacyTXTEnabledTPM12:
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 1, Minor: 2},
		}, nil
	case pcr.FlowIntelCBnT0T:
		acmPolicyStatusRegister, found := registers.FindACMPolicyStatus(statusRegisters)
		if !found {
			return nil, fmt.Errorf("ACM_POLICY_STATUS register not found")
		}
		return Properties{
			PropertyIntelTXT(true),
			PropertyTPMVersion{Major: 2, Minor: 0},
			PropertyIntelDCD(acmPolicyStatusRegister.BootPolicyDCD()),
			PropertyIntelDBI(acmPolicyStatusRegister.BootPolicyDBI()),
		}, nil
	case pcr.FlowAMDLocality0, pcr.FlowAMDLocality3, pcr.FlowLegacyAMDLocality0, pcr.FlowLegacyAMDLocality3:
		result := Properties{
			PropertyTPMVersion{Major: 2, Minor: 0},
			PropertyAMDPlatformSecurityProcessor(true),
		}
		if msg37Register, found := registers.FindMP0C2PMsg37(statusRegisters); found {
			result = append(result, PropertyAMDPlatformSecureBoot(msg37Register.IsPlatformSecureBootEnabled()))
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unknown flow: %s", flow)
	}
}

// ContainsAll returns if props is a subset of s.
func (s Properties) ContainsAll(props ...Property) bool {
	m := map[Property]struct{}{}
	for _, prop := range s {
		m[prop] = struct{}{}
	}

	for _, prop := range props {
		if _, ok := m[prop]; !ok {
			return false
		}
	}

	return true
}

// Validate returns an error if properties are invalid.
func (s Properties) Validate() error {
	mErr := &errors.MultiError{}

	m := map[reflect.Type]Property{}
	var prevPlatform *platformsecurity.ID
	for _, prop := range s {
		if prop == nil {
			mErr.Add(fmt.Errorf("property is nil"))
			continue
		}
		if prop.Tag() == tagUndefined {
			mErr.Add(fmt.Errorf("property %T:%v has no tag associated", prop, prop))
		}
		if platform := prop.Tag().PlatformSecurity(); platform != platformsecurity.IDUndefined {
			if prevPlatform == nil {
				prevPlatform = &platform
			} else if !compatiblePlatformSecurity(platform, *prevPlatform) {
				mErr.Add(fmt.Errorf("properties describe both %s and %s hardware platforms", platform, *prevPlatform))
			}
		}

		t := reflect.TypeOf(prop)
		current := m[t]
		if current == nil {
			m[t] = prop
		} else {
			if !reflect.DeepEqual(current, prop) {
				mErr.Add(fmt.Errorf("property %s is defined multiple times and contains a contradiction: %v and %v", strings.ReplaceAll(t.String(), "types.Property", ""), current, prop))
				break
			}
		}
	}

	return mErr.ReturnValue()
}

func compatiblePlatformSecurity(lhv, rhv platformsecurity.ID) bool {
	// CBnT and TXT and compatible
	if lhv == platformsecurity.IDIntelCBnT {
		lhv = platformsecurity.IDIntelTXT
	}
	if rhv == platformsecurity.IDIntelCBnT {
		rhv = platformsecurity.IDIntelTXT
	}
	return lhv == rhv
}
