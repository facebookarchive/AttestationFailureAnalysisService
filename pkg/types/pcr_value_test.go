package types

import (
	"crypto/sha1"
	"crypto/sha256"
	"github.com/bxcodec/faker/v3"
	"github.com/google/go-tpm/tpm2"
	"github.com/stretchr/testify/require"
	"reflect"
	"testing"
)

func init() {
	err := faker.AddProvider("Properties", func(v reflect.Value) (interface{}, error) {
		return Properties{
			PropertyAutoGenerated(true),
			PropertyTPMVersion{Major: 1, Minor: 2},
			PropertyIntelTXT(true),
			PropertyIntelDBI(true),
			PropertyIntelDCD(false),
			PropertyAMDPlatformSecureBoot(true),
		}, nil
	})
	if err != nil {
		panic(err)
	}
}

func TestPCRValueEquals(t *testing.T) {
	p := PCRValue{
		Index:    0,
		HashAlgo: tpm2.AlgSHA1,
		Value:    []byte{0x1, 0x2},
		Properties: Properties{
			PropertyIntelDCD(true),
			PropertyIntelDBI(false),
		},
	}

	t.Run("equals", func(t *testing.T) {
		require.True(t, p.Equals(p))
	})

	t.Run("different_index", func(t *testing.T) {
		p2 := p
		p2.Index = p.Index + 1
		require.False(t, p.Equals(p2))
	})

	t.Run("different_hash_alg", func(t *testing.T) {
		p2 := p
		p2.HashAlgo = tpm2.AlgSHA256
		require.False(t, p.Equals(p2))
	})

	t.Run("different_value", func(t *testing.T) {
		p2 := p
		p2.Value = append(p2.Value, 0x10)
		require.False(t, p.Equals(p2))
	})

	t.Run("shuffled_properties", func(t *testing.T) {
		p2 := p
		p2.Properties[0], p2.Properties[1] = p2.Properties[1], p2.Properties[0]
		require.True(t, p.Equals(p2))
	})

	t.Run("different_properties", func(t *testing.T) {
		p2 := p
		p2.Properties = append(p2.Properties, PropertyIntelTXT(true))
		require.False(t, p.Equals(p2))
	})
}

func TestPCRValueEqualForgotToCompareField(t *testing.T) {
	p := PCRValue{}
	require.NoError(t, faker.FakeData(&p))

	// Upstream github.com/bxcodec/faker library does not
	// support slice_len for byte/uints. Looking at fixing
	// it upstream, but may also just replace
	// So we're doing the dumb approach, if it's 0, reroll
	for len(p.Value) == 0 {
		faker.FakeData(&p)
	}

	v := reflect.ValueOf(&p).Elem()
	for fieldIdx := 0; fieldIdx < v.NumField(); fieldIdx++ {
		if v.Field(fieldIdx).IsZero() {
			require.NoError(t, faker.FakeData(v.Field(fieldIdx).Addr().Interface()))
		}

		p2 := p
		v2 := reflect.ValueOf(&p2).Elem()
		v2.Field(fieldIdx).Set(reflect.Zero(v2.Field(fieldIdx).Type()))

		require.False(t, p.Equals(p2))
	}
}

func TestPCRValuesEquals(t *testing.T) {
	p1 := PCRValue{
		Index:    0,
		HashAlgo: tpm2.AlgSHA1,
		Value:    []byte{0x1, 0x2},
		Properties: Properties{
			PropertyIntelDCD(true),
			PropertyIntelDBI(false),
		},
	}

	p2 := PCRValue{
		Index:    0,
		HashAlgo: tpm2.AlgSHA256,
		Value:    []byte{0x1, 0x2, 0x3, 0x4},
		Properties: Properties{
			PropertyIntelDCD(true),
			PropertyIntelDBI(false),
		},
	}

	p3 := PCRValue{
		Index:    0,
		HashAlgo: tpm2.AlgSHA256,
		Value:    []byte{0x4, 0x5, 0x6, 0x7},
		Properties: Properties{
			PropertyIntelTXT(true),
		},
	}

	require.True(t, PCRValues{p1, p2}.Equals(PCRValues{p2, p1}))
	require.True(t, PCRValues{p1, p2, p2}.Equals(PCRValues{p2, p1, p2}))
	require.False(t, PCRValues{p1, p2, p2}.Equals(PCRValues{p1, p1, p2}))
	require.False(t, PCRValues{p1, p2}.Equals(PCRValues{p1, p3}))
}

func TestNewPCR0Value(t *testing.T) {
	t.Run("pcr0_sha1", func(t *testing.T) {
		value := make([]byte, sha1.Size)

		pcr0 := NewPCRValue(0, value, PropertyIntelDBI(true), PropertyIntelTXT(false))
		require.Zero(t, pcr0.Index)
		require.Equal(t, PCR0SHA1Tag, pcr0.PCRBankTag())
		require.Equal(t, tpm2.AlgSHA1, pcr0.HashAlgo)
		require.Equal(t, value, pcr0.Value)
		require.Equal(t, Properties{PropertyIntelDBI(true), PropertyIntelTXT(false)}, pcr0.Properties)
	})

	t.Run("pcr0_sha256", func(t *testing.T) {
		value := make([]byte, sha256.Size)

		pcr0 := NewPCRValue(0, value, PropertyIntelDBI(true), PropertyIntelTXT(false))
		require.Zero(t, pcr0.Index)
		require.Equal(t, PCR0SHA256Tag, pcr0.PCRBankTag())
		require.Equal(t, tpm2.AlgSHA256, pcr0.HashAlgo)
		require.Equal(t, value, pcr0.Value)
		require.Equal(t, Properties{PropertyIntelDBI(true), PropertyIntelTXT(false)}, pcr0.Properties)
	})

	t.Run("pcr0_unknown", func(t *testing.T) {
		value := make([]byte, 10)

		pcr0 := NewPCRValue(0, value, PropertyIntelDBI(true), PropertyIntelTXT(false))
		require.Zero(t, pcr0.Index)
		require.Zero(t, pcr0.PCRBankTag())
		require.Equal(t, tpm2.AlgUnknown, pcr0.HashAlgo)
		require.Equal(t, value, pcr0.Value)
		require.Equal(t, Properties{PropertyIntelDBI(true), PropertyIntelTXT(false)}, pcr0.Properties)
	})
}

func TestPCR0ValueHashAlgoTag(t *testing.T) {
	t.Run("pcr0_sha1_tag_detection", func(t *testing.T) {
		pcr := PCRValue{
			Index: 0,
			Value: make([]byte, sha1.Size),
		}
		require.Equal(t, PCR0SHA1Tag, pcr.PCRBankTag())
	})

	t.Run("pcr0_sha256_tag_detection", func(t *testing.T) {
		pcr := PCRValue{
			Index: 0,
			Value: make([]byte, sha256.Size),
		}
		require.Equal(t, PCR0SHA256Tag, pcr.PCRBankTag())
	})

	t.Run("pcr1_sha1_tag_detection", func(t *testing.T) {
		pcr := PCRValue{
			Index: 1,
			Value: make([]byte, sha1.Size),
		}
		require.Equal(t, PCR1SHA1Tag, pcr.PCRBankTag())
	})

	t.Run("unknown", func(t *testing.T) {
		pcr := PCRValue{
			Index: 0,
			Value: make([]byte, 2),
		}
		require.Zero(t, pcr.PCRBankTag())
	})

	t.Run("pcr2", func(t *testing.T) {
		pcr := PCRValue{
			Index: 2,
			Value: make([]byte, sha1.Size),
		}
		require.Zero(t, pcr.PCRBankTag())
	})
}
